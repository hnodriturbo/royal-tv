generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id               String                 @id @default(uuid()) @db.Uuid
  name                  String
  email                 String                 @unique
  username              String                 @unique
  password              String
  role                  Role                   @default(user)
  whatsapp              String?
  telegram              String?
  preferredContactWay   PreferredContactWay    @default(email)
  sendEmails            Boolean                @default(true)
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  freeTrials            FreeTrial[]            @relation("UserFreeTrials")
  liveChatConversations LiveChatConversation[] @relation("LiveConversations")
  liveChatMessages      LiveChatMessage[]      @relation("LiveMessages")
  subscriptions         Subscription[]         @relation("UserSubscriptions")
  subscriptionPayments  SubscriptionPayment[]  @relation("UserSubscriptionPayments")
  notifications         Notification[]         @relation("UserNotifications")

  @@index([username])
  @@index([email])
}

model LiveChatConversation {
  conversation_id String            @id @default(uuid()) @db.Uuid
  owner_id        String            @db.Uuid
  subject         String?
  read            Boolean           @default(false)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  owner           User              @relation("LiveConversations", fields: [owner_id], references: [user_id], onDelete: Cascade, map: "LiveChatConversation_user_id_fkey")
  messages        LiveChatMessage[] @relation("LiveMessages")

  @@index([owner_id], map: "LiveChatConversation_user_id_idx")
}

model LiveChatMessage {
  message_id      String               @id @default(uuid()) @db.Uuid
  conversation_id String               @db.Uuid
  sender_id       String?              @db.Uuid
  guest_id        String?
  sender_is_admin Boolean              @default(false)
  message         String
  status          MessageStatus        @default(sent)
  readAt          DateTime?
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  conversation    LiveChatConversation @relation("LiveMessages", fields: [conversation_id], references: [conversation_id], onDelete: Cascade)
  sender          User?                @relation("LiveMessages", fields: [sender_id], references: [user_id], onDelete: Cascade, map: "LiveChatMessage_user_id_fkey")

  @@index([conversation_id])
  @@index([status])
  @@index([sender_id], map: "LiveChatMessage_user_id_idx")
}

model Subscription {
  subscription_id       String                @id @default(uuid()) @db.Uuid
  user_id               String                @db.Uuid
  order_id              String?
  subscription_username String?
  subscription_password String?
  subscription_url      String?
  subscription_other    String?
  additional_info       String?
  status                SubscriptionStatus    @default(pending)
  startDate             DateTime?
  endDate               DateTime?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt
  user                  User                  @relation("UserSubscriptions", fields: [user_id], references: [user_id], onDelete: Cascade)
  payments              SubscriptionPayment[]

  @@index([user_id])
  @@index([status])
}

model SubscriptionPayment {
  id              String        @id @default(uuid()) @db.Uuid
  user_id         String        @db.Uuid
  subscription_id String?       @db.Uuid
  payment_id      String?       @unique
  order_id        String
  invoice_id      String?
  status          PaymentStatus
  currency        String?
  amount_paid     Float?
  amount_received Float?
  pay_currency    String?
  pay_address     String?
  network         String?
  received_at     DateTime?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  subscription    Subscription? @relation(fields: [subscription_id], references: [subscription_id], onDelete: Cascade)
  user            User          @relation("UserSubscriptionPayments", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([payment_id])
  @@index([user_id])
}

model FreeTrial {
  trial_id            String          @id @default(uuid()) @db.Uuid
  user_id             String          @db.Uuid
  free_trial_username String?
  free_trial_password String?
  free_trial_url      String?
  free_trial_other    String?
  additional_info     String?
  startDate           DateTime?
  endDate             DateTime?
  status              FreeTrialStatus @default(disabled)
  claimedAt           DateTime        @default(now())
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt
  user                User            @relation("UserFreeTrials", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id])
  @@index([status])
}

model Notification {
  notification_id String           @id @default(uuid()) @db.Uuid
  user_id         String           @db.Uuid
  title           String
  body            String
  link            String?
  type            NotificationType
  is_read         Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation("UserNotifications", fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id])
}

enum Role {
  admin
  user
}

enum PreferredContactWay {
  email
  whatsapp
  telegram
  website
}

enum MessageStatus {
  sent
  read
  deleted
  edited
}

enum SubscriptionStatus {
  active
  expired
  canceled
  pending
  disabled
}

enum PaymentStatus {
  waiting
  confirming
  confirmed
  finished
  failed
  expired
  refunded
}

enum FreeTrialStatus {
  active
  disabled
  pending
}

enum NotificationType {
  subscription
  payment
  freeTrial
  liveChatMessage
  newUserRegistration
}
